% !TEX root =main.tex

\subsection{Subroutines for  Encoding-Decoding Verdicts}


In this section, we present verdict encoding and decoding protocols. They let a third party $\mathcal{I}$, e.g., $\mathcal{DR}$, find out whether threshold  arbiters voted $1$, while satisfying the following  requirements.  The protocols should (1) generate unlinkable verdicts, (2)  not require arbiters to interact with each other for each customer, and (3) be  efficient. Since, the second and third requirements are self-explanatory,  we only explain the first one.  Informally, the first property requires  that the protocols should generate encoded verdicts and final verdict in a way that $\mathcal{I}$,  given the encoded verdicts and final verdict, should not be able to (a)   link a  verdict to an arbiter (except when all arbiters' verdicts are $0$), and (b) find out the total number of $1$ or $0$ verdicts when they provide different verdicts.  In this section, we present two variants of verdict encoding and decoding protocols, where each variant contains two protocol. The first variant is highly efficient and suitable for the case where the threshold is $1$. The second variant is  generic and works for any threshold. The latter variant is less efficient than the former one, but it is still efficient. Below, we explain each variant. 


\subsubsection{Variant 1: Highly Efficient Verdict  Encoding-Decoding Protocols.}

Here, we present two efficient verdict encoding and decoding protocols; namely, Private Verdict Encoding (PVE) and Final Verdict Decoding (FVD) protocols, that lets $\mathcal{I}$ find out whether at least one arbiter voted $1$, while satisfying the above requirements.  At a high level, the protocols work as follows.  The arbiters only once for all customers agree on a secret key of a pseudorandom function. This key will let each of them   generate a pseudorandom masking values such that if all masking values are ``XOR''ed, they would cancel out each other and result $0$.\footnote{This is similar to the idea used in the XOR-based secret sharing \cite{Schneier0078909}.} Each arbiter represents its verdict by (i) representing it as a parameter which is set to either $0$ if the verdict is $0$ or a random value if the verdict is $1$, and then (ii) masking this parameter by the above  pseudorandom value.  It sends the result to $\mathcal{I}$.  To decode the final verdict and find out whether any arbiter voted $1$, $\mathcal{I}$  does XOR all encoded verdicts. This removes the masks and XORs are verdicts' representations.  If the result is $0$, then    all arbiters must have voted $0$; therefore,  the final verdict is $0$. However, if the result is not $0$ (i.e., a random value), then at least one of the arbiters voted $1$, so  the final verdict is $1$. We present the encoding  and decoding protocols in figures \ref{fig:PVE} and \ref{fig:FVD} respectively.
 
 
 Not that the protocols' correctness holds with an overwhelming probability. In particular, if two arbiters  represent their verdict by an identical random value, then when they are XORed they would cannel out each other which can affect the result's correctness. The same holds if the XOR of  multiple verdicts' representations results in a value that can cancel out another verdict's representation. Nevertheless, the probability that such an event occurs is negligible in the security parameter $|p|=\lambda$, i.e., at most   $\frac{1}{2^{\st \lambda}}$. It is evident that PVE and FVD protocols meet properties (2) and (3). The primary reason they also meet  property (1) is that each masked verdict reveals nothing about the verdict (and its representation) and  given the final verdict, $\mathcal{I}$ cannot distinguish between the case where there is exactly one arbiter that voted  $1$ and the case where multiple arbiters voted $1$, as in both cases $\mathcal{I}$   extracts only a single random value, which reveals nothing about the number of arbiters which voted $0$ or $1$. We will use this variant in the PwDR protocol. 
 

\subsubsection{Variant 2: Generic Verdict  Encoding-Decoding Protocols.} Now, we present two  efficient generic verdict  encoding-decoding protocols, denoted by GPVE and GFVD,  that let $\mathcal{I}$ find out whether at least $e$ arbiters voted $1$, where $e$ can be any integer in the range $[1, n]$. This variant is  built upon the previous one; however, it uses a novel idea that relies on  Bloom filter and combinatorics.  At a high level, the encoding protocol works as follows.  The arbiters (similar to Variant 1) agree on a secret key of a pseudorandom function. As before, each arbiter will use this key to  generate a pseudorandom masking value such that if all arbiters' masking values are ``XOR''ed, they would cancel out each other. Then, each arbiter represents its verdict by a parameter. In particular, if its verdict is $0$, then  it  sets the parameter to either $0$. However, if   its verdict is $1$, it sets the parameter to a fresh \emph{pseudorandom} value $\alpha_{\st j}$ (instead of a random value used in Variant 1),  where this  pseudorandom value is derived from the above key. Therefore, there would be a set $A=\{\alpha_{\st 1},..., \alpha_{\st n}\}$ from which  $\mathcal{D}_{\st j}$ would pick $\alpha_{\st j}$ to represent its verdict if its verdict is $1$. Next, each arbiter masks its verdict representation by its masking  value. It sends the result to 
 $\mathcal{I}$.
 

Arbiter $\mathcal{D}_{\st n}$ also generates a Bloom filter that contains the combinations of set $A$'s elements, regardless of whether a certain arbiter's  vote is $0$ or $1$. More specifically,  for every integer $i$ in the range $[e,n]$, computes the combinations, without repetition, of $i$ elements from set $A=\{\alpha_{\st 1},..., \alpha_{\st n}\}$, where when multiple elements are taken at a time (i.e., $i>1$), the elements are XORed with each other. Let $W=\{(\alpha_{\st 1}\oplus ... \oplus \alpha_{\st e}),  (\alpha_{\st 2}\oplus  ... \oplus \alpha_{\st e+1}), ..., (\alpha_{\st 1}\oplus ... \oplus \alpha_{\st n})\}$ be the result. For instance, when $n=3$ and $e=2$,  we would have $W=\{(\alpha_{\st 1}\oplus \alpha_{\st 2}),  (\alpha_{\st 2}\oplus  \alpha_{\st 3}), (\alpha_{\st 1}\oplus \alpha_{\st 3}), (\alpha_{\st 1}\oplus \alpha_{\st 2} \oplus \alpha_{\st n})\}$. After that, it generates an empty Bloom filter and  inserts all elements of $W$ into this Bloom filter. Let $\mathtt{BF}$ be the Bloom filter that encodes $W$'s elements. It sends $\mathtt{BF}$ to $\mathcal{I}$. To decode and extract the final verdict, as in Variant 1, $\mathcal{I}$ does XOR all masked verdict representations which  removes the masking values and XORs are verdictsâ€™ representations. If the result is $0$, then $\mathcal{I}$ concludes that all arbiters must have voted $0$ (with a high probability); so, it sets the final verdict to $0$. However, if the result is a non-zero value, then it checks whether the value is in the Bloom filter. If it is, then it concludes that at least threshold arbiters voted $1$, so it sets the final vector to $1$. Otherwise (if the value is not in the Bloom filter), it concludes that less than threshold arbiters voted $1$; therefore, it sets the final verdict to $0$.  Figures \ref{fig:GPVE} and \ref{fig:GFVD}, in Appendix \ref{sec::Generic-Verdict-Encoding-Decoding-Protocols}, present the  GPVE and GFVD protocols in detail. 



%\item[$\bullet$] for every integer $i$ in the range $[e,n]$, computes the combinations (without repetition) of $i$ elements from set $\{\alpha_{\st 1},..., \alpha_{\st n}\}$, where the combination operation is XOR. Let $W=\{(\alpha_{\st 1}\oplus \alpha_{\st 2}\oplus... \oplus \alpha_{\st e}), (\alpha_{\st 2}\oplus \alpha_{\st 3}\oplus ... \oplus \alpha_{\st e+1}), ..., (\alpha_{\st 1}\oplus \alpha_{\st 2}\oplus... \oplus \alpha_{\st n})\}$ be the result.  
%

%\item[$\bullet$] constructs an empty Bloom filter. Then, it inserts all elements of $W$ into this Bloom filter. Let $\mathtt{BF}$ be the Bloom filter encoding $W$'s elements. 
 
  
  
 
 
 
 



 %and then (ii) masking this parameter by the above pseudorandom value. It sends the result to I. 

%Now, we explain how the GPVE and GFVD work. 





%In Appendix \ref{sec::bloom-filter-}, we explain how the Bloom filter parameters can be set.  




%
%Here, we present two efficient verdict encoding and decoding protocols; namely, Private Verdict Encoding (PVE) and Final Verdict Decoding (FVD) protocols. Their goal is to let a third party $\mathcal{I}$, e.g., $\mathcal{DR}$, find out whether at least one arbiter voted $1$, while satisfying the following  requirements.  The protocols should (1) generate unlinkable verdicts, (2)  not require arbiters to interact with each other for each customer, and (3) be  efficient. Since, the second and third requirements are self-explanatory,  we only explain the first one.  Informally, the first property requires  that the protocols should generate encoded verdicts and final verdict in a way that $\mathcal{I}$,  given the encoded verdicts and final verdict, should not be able to (a)   link a  verdict to an arbiter (except when all arbiters' verdicts are $0$), and (b) find out the total number of $1$ or $0$ verdicts when they provide different verdicts. 
%
%
%
% At a high level, the protocols work as follows.  The arbiters only once for all customers agree on a secret key of a pseudorandom function. This key will allow each of them to generate a pseudorandom masking values such that if all masking values are ``XOR''ed, they would cancel out each other and result $0$.\footnote{This is similar to the idea used in the XOR-based secret sharing \cite{Schneier0078909}.}
% 
% 
% 
% 
% 
%Each arbiter represents its verdict by (i) representing it as a parameter which is set to either $0$ if the verdict is $0$ or to a random value if the verdict is $1$, and then (ii) masking this parameter by the above  pseudorandom value.  It sends the result to $\mathcal{I}$.  To decode the final verdict and find out whether any arbiter voted $1$, $\mathcal{I}$  does XOR all encoded verdicts. This removes the masks and XORs are verdicts' representations.  If the result is $0$, then    all arbiters must have voted $0$; therefore,  the final verdict is $0$. However, if the result is not $0$ (i.e., a random value), then at least one of the arbiters voted $1$, so  the final verdict is $1$. We present the encoding  and decoding protocols in figures \ref{fig:PVE} and \ref{fig:FVD} respectively.
% 
% 
% Not that the protocols' correctness holds, except  a negligible  probability. In particular, if two arbiters  represent their verdict by an identical random value, then when they are XORed they would cannel out each other which can affect the result's correctness. The same holds if the XOR of  multiple verdicts' representations results in a value that can cancel out another verdict's representation. Nevertheless, the probability that such an event occurs is negligible in the security parameter, i.e., at most   $\frac{1}{2^{\st \lambda}}$. It is evident that PVE and FVD protocols meet properties (2) and (3). The primary reason they also meet  property (1) is that each masked verdict reveals nothing about the verdict (and its representation) and  given the final verdict, $\mathcal{I}$ cannot distinguish between the case where there is exactly one arbiter that voted  $1$ and the case where multiple arbiters voted $1$, as in both cases $\mathcal{I}$   extracts only a single random value, which reveals nothing about the number of arbiters which voted $0$ or $1$. 
% 
%




\begin{figure}[!ht]
\setlength{\fboxsep}{0.7pt}
\begin{center}
\begin{boxedminipage}{12.3cm}
\small{
\underline{$\mathtt{PVE}(\bar{k}_{\st 0}, \text{ID},  w_{\st j}, o, n,  j)\rightarrow  \bar{  w}_{\st j}$}\\
%
\begin{itemize}
\item \noindent\textit{Input.} $\bar{k}_{\st 0}$: a key of  pseudorandom function $\mathtt{PRF}(.)$, $\text{ID}$: a unique identifier, $ w_{\st j}$: a  verdict, $o$: an offset, $n$: the total number of  arbiters,  and  $j$: an arbiter's index.
%
\item \noindent\textit{Output.} $\bar{  w}_{\st j}$:  an  encoded verdict.  
%
\end{itemize}
Arbiter $\mathcal{D}_{\st j}$ takes the following steps.
\begin{enumerate}
%
\item\label{ZSPA:val-gen} computes a  pseudorandom  value,  as follows. 
%
\begin{itemize}
%
\item[$\bullet$]$ \text{ if } j< n: r_{\st j}=\mathtt{PRF}(\bar k_{\st 0}, o||j||\text{ID})$.\\
%
\item [$\bullet$] $ \text{ if } j=n: r_{\st j}= \bigoplus\limits^{\st n-1}_{\st i=1} r_{\st i}$.
%
\end{itemize}
%
\item  sets a fresh parameter, $w'_{\st j}$, as below. 
%
\begin{equation*}
   w'_{\st j}= 
\begin{cases}
   0,              & \text{if } w_{\st j}=0\\
   \alpha_{\st j}\stackrel{\st\$}\leftarrow \mathbb{F}_{\st p} ,& \text{if } w_{\st j}=1\\

    %0,              & \text{if } w_{\st j}=0
\end{cases}
\end{equation*}
%
\item encodes  $w'_{\st j}$ as follows. %$\forall i,1\leq i\leq s:$
%
$\bar w_{\st j}= w'_{\st j}\oplus r_{\st j}$.
%
\item outputs $\bar{ w}_{\st j}$.


\
 \end{enumerate}
 
}
\end{boxedminipage}
\end{center}
\caption{Private Verdict Encoding  (PVE) Protocol} 
\label{fig:PVE}
\end{figure}
%
\begin{figure}[!ht]
\setlength{\fboxsep}{0.7pt}
\begin{center}
\begin{boxedminipage}{12.3cm}
\small{
\underline{$\mathtt{FVD}(n,  \bar{\bm w})\rightarrow  v$}\\
%
\begin{itemize}
\item \noindent\textit{Input.} $n$:  the total number of  arbiters,  and  $\bar{\bm w}=[\bar{ w}_{\st 1},..., \bar{ w}_{\st n}]$:  a vector of all arbiters' encodes  verdicts.
%
\item \noindent\textit{Output.} $v$: final verdict.  
%
\end{itemize}
A third-party $\mathcal{I}$ takes the following steps.
\begin{enumerate}
%
\item combines  all arbiters' encoded verdicts, $\bar w_{\st j}\in \bar{\bm {w}}$, as follows. 
%
$c= \bigoplus\limits^{\st n}_{\st j=1} \bar w_{\st j}$
%
\item sets the final verdict $v$ depending on the content of $c$. Specifically, 
%
\begin{equation*}
   v= 
\begin{cases}
    0,              &\text{if } c= 0\\
   1 ,& \text{otherwise }\\

\end{cases}
\end{equation*}
%
\item outputs  $v$. 

\
 \end{enumerate}
 
}
\end{boxedminipage}
\end{center}
\caption{Final Verdict Decoding  (FVD) Protocol} 
\label{fig:FVD}
\end{figure}

