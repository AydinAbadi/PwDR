% !TEX root =main.tex

\section{Further Discussion on the Verdict Encoding-decoding Protocols}\label{sec:: Further-Discussion-on-the-Encoding-decoding-Protocol}

%In this section, we briefly explain why  existing  solutions are not suitable replacements for the our  verdict encoding-decoding protocols. 



Recall that each variant of our verdict encoding-decoding protocol is a voting mechanism. It  lets a third party, $\mathcal{I}$, find out if a threshold of the auditors voted $1$, while (i) generating unlinkable verdicts, (ii) not requiring auditors to interact with each other for each customer, (iii) hiding the number of $0$ or $1$ verdicts from  $\mathcal{I}$, and (iv) being  efficient. Therefore, it is natural to ask: 

\begin{center}
\emph{Is there   any {e-voting} protocol, in the literature, that can  simultaneously satisfy all the above requirements?}
\end{center}


The short answer is no. Recently, a provably secure  e-voting protocol that can hide the number of $1$ and $0$ votes has been proposed by K{u}sters \textit{et al.} \cite{KustersL00020}. Although this scheme can satisfy the above \emph{security} requirements, it imposes a high computation cost, as  it involves computationally expensive primitives such as zero-knowledge proofs, threshold public-key encryption scheme, and generic multi-party computation. In contrast, our verdict encoding-decoding protocols rely on much more lightweight operations such as XOR and hash function evaluations.  We also  highlight that our verdict encoding-decoding protocols are in a different setting than the one in which most of the e-voting protocols are. Because the former protocols are in the setting where there exists a small number of auditors (or voters) which are trusted and can interact with each other once; whereas, the latter (e-voting) protocols are in a more   generic setting where there is a large number of  voters, some of which might be malicious, and they are not   required to interact with each other. 


Note that each variant of our verdict encoding-decoding protocol requires every auditor to provide an encoded vote  in order for $\mathcal{I}$ to extract the final verdict. To let each variant terminate and $\mathcal{I}$ find out the final verdict in the case where a  set of  auditors do not provide their vote, we can integrate the    following idea into each variant. We define a manager auditor, say $\mathcal{D}_{\st n}$, which is always responsive and keeps track of missing votes. After the voting time elapses and $\mathcal{D}_{\st n}$ realises a certain  number of auditors did not provide their encoded vote, it provides $0$ votes on their behalf and masks them using the  auditors' masking values. 









