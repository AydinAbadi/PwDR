% !TEX root =main.tex



\section{Bloom Filter}\label{sec::bloom-filter-}

A Bloom filter \cite{DBLP:journals/cacm/Bloom70} is a compact data structure for probabilistic efficient  elements'  membership checking. A Bloom filter is an array of $\bar  m$ bits that are  initially all set to zero. It  represents $\bar n$  elements.  A Bloom filter comes along with  $\bar k$ independent hash functions. To insert an element, all the  hash values of the element are computed and their corresponding bits in the filter are set to $1$. To check an element's  membership, all its hash values are re-computed and checked whether all are set to one in the filter. If all the corresponding bits are one, then the element is probably in the filter; otherwise, it is not. In Bloom filters false positives are possible, i.e., it is possible that an element is not in the set, but the membership query shows that it is. According to \cite{BoseGKMMMST08}, the upper bound of the false positive probability is: $\bar q=\bar p^{\scriptscriptstyle \bar  k}(1+O(\frac{\bar k}{\bar p}\sqrt{\frac{\ln \bar m - \bar k \ln \bar  p}{\bar m}}))$,  where $\bar p$ is the probability that a particular bit in the filter is set to $1$ and calculated as: $\bar p=1-(1-\frac{1}{\bar m})^{\scriptscriptstyle \bar k\bar n}$. The efficiency of a Bloom filter depends
on  $\bar m$ and $\bar k$. The lower bound of $\bar m$  is $\bar  n \log_{\scriptscriptstyle 2}
\bar e \cdot\log_{\scriptscriptstyle 2} \frac{1}{\bar q}$, where $\bar e$ is the base of natural logarithms,  while the optimal number of hash functions is    $\log_{\scriptscriptstyle 2} \frac{1}{\bar q}$, when $\bar m$ is optimal. In this paper, we only use optimal $\bar k$ and $\bar m$. In practice, we would like to have a predefined acceptable upper bound on false positive probability, e.g., $\bar q=2^{\scriptscriptstyle - 40}$. Given $\bar q$ and $\bar n$, we can determine the rest  of the parameters. 

