%!TEX root = main.tex

%\section{Notations and Assumptions}
%
%
%
%
%
%
%There are three main algorithms involved in the protocol; namely, $\mathtt{setupNewPayee}(.)$, $\mathtt{ammendExistingPayee}(.)$, and $\mathtt{pay}(.)$.
%The first two algorithms are executed by a smart contract while the third one is executed off-chain by a bank. We denote the inputs of algorithms $\mathtt{setupNewPayee}(.), \mathtt{ammendExistingPayee}(.)$, and $\mathtt{pay}(.)$ by $in_{\st s}, in_{\st a}$, and $in_{\st p}$ respectively. A null value is denoted by $\phi$. To determine the effectiveness of a warning we define a deterministic function   $\mathtt{f}(v_{\st 1}, ..., v_{\st n})\rightarrow b$  that takes $n$ binary inputs (or verdicts)  and outputs a binary value, $b$. For the sake of simplicity, we let this function output $1$ if the majority of the inputs are $1$; otherwise, it outputs $0$.  If $b=1$, it is said the warning is effective; otherwise (i.e.,   $b=0$), it is not effective. We assume the source code of the online banking system is static, is not updated, and any change to the source code can be detected (e.g., the bank can use a cryptographic commitment to commit to the source code). Moreover, we assume the online banking  system is secure.  %Moreover, we assume a customer does not collude with the APP scammer. 

%In our scheme, the bank requires to send a confirmation message to the smart contract after it transfers the customer's money. Since the transfer of money is performed off-chain, there is a possibility that  disputes occur between   the customer and bank in the case where there is an inconsistency between the money transfer and the confirmation (e.g., the bank transferred the money but did not send the confirmation). To allow such dispute to be resolved, we define a deterministic function   $\mathtt{madePayment}(w_{\st 1}, ..., w_{\st n})\rightarrow d$,  which takes $n$ binary verdicts of arbiters and outputs a binary value, $d$. This function outputs $1$ if the majority of the inputs are $1$; otherwise, it outputs $0$.  If $d=1$, it is said the payment has been made; otherwise (i.e.,   $d=0$), it has not been made. We assume the source code of the online banking system is static, is not updated, and any change to the source code can be detected (e.g., the bank can use a cryptographic commitment to commit to the source code).






\input{PwDR-Overview}

\input{Definition}





\section{Payment with Dispute Resolution Protocol}

In this section, first we  provide an outline of the PwDR protocol. Then, we present a few subroutines that will be used in this protocol. After that, we describe the PwDR protocol in detail. 




\subsection{An Overview of  the PwDR Protocol}


In this section, we provide an overview of the  PwDR protocol. For the sake of simplicity, we assume $\mathcal{C}$ wants to transfer a certain amount of money to a new payee. Initially, only for once,  customer  $\mathcal{C}$ and bank  $\mathcal{B}$   agree on a smart contract  $\mathcal{S}$. They also use the SAP to provably agree on two private statements that include two  secret keys. The keys will be used to encrypt  messages sent to $\mathcal{S}$ and will be used  by $\mathcal{D}_{\st j}$s and $\mathcal{DR}$ to decrypted related messages. When $\mathcal{C}$ wants to transfer money to a new payee, it   signs into the standard online banking system. Then, it generates an update  request that specifies the new payee's detail,  encrypts the request, and sends the result to  $\mathcal{S}$. After that, $\mathcal{B}$ decrypts and checks the request's validity, e.g.,  whether it  meets its internal policy or  the requirements of the ``Confirmation of Payee'' \cite{CoP}. Depending on the  request's content, $\mathcal{B}$ generates a pass or warning message. It encrypts the message and sends the result to $\mathcal{S}$. Then, $\mathcal{C}$ checks $\mathcal{B}$'s message and depending on the content of this message, it decides whether it wants to proceed to made  payment. If it decides to do so, then it sends an encrypted payment detail to $\mathcal{S}$. This  allows $\mathcal{B}$ to decrypt the message and locally transfer the amount of money specified in $\mathcal{C}$'s message. Once the money is transferred, $\mathcal{B}$ sends an encrypted  ``paid" message to $\mathcal{S}$. 


%Initially, the customer  $\mathcal{C}$ and bank  $\mathcal{B}$   agree on a smart contract  $\mathcal{S}$. They also use SAP to provably agree on two private statements; each statement includes a secret key, one is used to encrypt  messages that should be decrypted by all parties except $\mathcal{DR}$ and the other one is used to encrypt  messages that are supposed to be decrypted by $\mathcal{DR}$. For the sake of simplicity, we assume $\mathcal{C}$ wants to transfer a certain amount of money to a new payee. To do so, it   signs into the standard online banking system.  It generates an update  request that specifies the new payee's detail, it encrypts the request and sends the result to  $\mathcal{S}$. After that, $\mathcal{B}$ decrypts and checks this request's validity, e.g.,  whether it  meets its internal policy or  the requirements of the Confirmation of Payee (CoP) \cite{CoP}. Depending on the  request's content, $\mathcal{B}$ generates a pass or warning message. It encrypts the message and sends the result to $\mathcal{S}$. Then, $\mathcal{C}$ checks $\mathcal{B}$'s message and depending on the content of this message, it decides whether it wants to proceed to made  payment. If it decides to do so, then it sends an encrypted payment detail to $\mathcal{S}$. This  allows $\mathcal{B}$ to decrypt the message and locally transfer the amount of money specified in $\mathcal{C}$'s message. Once the money is transferred, $\mathcal{B}$ sends encrypted  ``paid" message to $\mathcal{S}$. 






%When it decides to invoke either  (a) algorithm $\mathtt{setupNewPayee}(.)$ to setup a new payee, or (b) algorithm $\mathtt{ammendExistingPayee}(.)$ to modify the existing payee's detail,  it sends the inputs of the related algorithm to $\mathcal{S}$ which runs the associated algorithm.  



%After a fixed time period, $\mathcal{B}$ checks the validity of the inputs that are registered by $\mathcal{C}$ in $\mathcal{S}$.  If the check fails (e.g., the input does not meet  the requirements of the Confirmation of Payee \cite{CoP}), then it sends  to $\mathcal{S}$ a warning message that includes the waring's detail; otherwise, it sends to $\mathcal{S}$ the ``pass'' message. Note that  $\mathcal{C}$ comes across with the same warning when it interacts with the online payment system's user interface.   Depending on the content of $\mathcal{B}$'s message, $\mathcal{C}$ decides whether it wants to proceed to made  payment. If it decides to make payment, then it sends the payment's detail to $\mathcal{S}$. This  allows $\mathcal{B}$ to locally transfer the amount of money specified in $\mathcal{C}$'s message. 


%Once the money is transferred, $\mathcal{B}$ sends the message ``paid" to $\mathcal{S}$. 


Once $\mathcal{C}$ realises that it has fallen victim to an APP fraud, it  raises a dispute. In particular, it  generates  an encrypted complaint that could  challenge the effectiveness of the warning and/or any payment inconsistency (as explained in Section \ref{sec::Linking Off-chain-Payments-with-contract}). It can also  include in the complaint an  evidence/certificate, e.g., to claim that it falls into  the vulnerable customer category as defined in \cite{CRM-code}. $\mathcal{C}$ encrypts the complaint. It also   encrypts the secret key (under arbiters' public key) that it uses to encrypt the messages. It sends to $\mathcal{S}$ the ciphertexts along with a proof asserting the secret key's correctness.  Upon receiving $\mathcal{C}$'s complaint, each committee member verifies the proof. If the verification passes, it decrypts and compiles $\mathcal{C}$'s complaint to generate a (set of) verdict. Then, each committee member encodes its verdict and sends the  encryption of the encoded verdict to $\mathcal{S}$. To resolve a dispute between $\mathcal{C}$ and $\mathcal{B}$, either of them can  invoke $\mathcal{DR}$. To do so, they  directly send to it one of the above secret keys and a proof asserting that key was generated correctly.   $\mathcal{DR}$ verifies the proof. If the verification passes it locally decrypts the encrypted encoded verdicts (after retrieving them from $\mathcal{S}$) and then combines the result to find out the final verdict.  If the final verdict indicates the legitimacy of  $\mathcal{C}$'s complaint, then $\mathcal{C}$ must be reimbursed.   Note, the verdicts are encoded in such a way that even after decrypting them, the dispute resolver cannot link a verdict to a committee member or even figure out how many $1$ or $0$ verdicts have been provided  (except when all verdicts are $0$). However, it can find out whether at least threshold committee members voted  in faviour of $\mathcal{C}$. Shortly, we present  novel verdict encoding-decoding protocols that offer the above features. 




%  Upon receiving $\mathcal{C}$'s message, $\mathcal{S}$ carries out the following primary checks: (a)   $\mathcal{C}$ requested a payment, (b) a warning was provided, (c)   the warning was effective, and (d)   the (off-chain) payment has been made. $\mathcal{S}$ concludes $\mathcal{C}$ should be reimbursed if both checks (a) and (d)  pass while either (b) or (c)  fails. 

%Before, we provide the  PwDR protocol in detail, we present two subroutines that will be needed and invoked by the PwDR protocol. 


\input{check-pass}


\subsection{The PwDR Protocol}
In this section, we present the PwDR protocol in detail. 




%At a high level, the protocol works as follows. 

\begin{enumerate}

\item \underline{\textit{Generating  Certificate Parameters}}.  $\mathtt{keyGen}(1^{\st \lambda})\rightarrow (sk,pk)$

The certificate generator  takes   step \ref{signature-keygen} and an arbiter takes step \ref{encryption-keygen} below. 

\begin{enumerate}
\item\label{signature-keygen} calls $\mathtt{Sig.keyGen}(1^{\st \lambda})\rightarrow (sk_{\st\mathcal{G}}, pk_{\st\mathcal{G}})$ to generate  signing secret key $sk_{\st\mathcal{G}}$ and  verfiying public key $pk_{\st\mathcal{G}}$. It publishes the public key, $pk_{\st\mathcal{G}}$.
%
\item\label{encryption-keygen} calls $\tilde{\mathtt{keyGen}}(1^{\st\lambda})\rightarrow({sk}_{\st\mathcal {D}}, {pk}_{\st\mathcal {D}})$ to generate  decrypting secret key ${sk}_{\st\mathcal {D}}$ and encrypting public key ${pk}_{\st\mathcal {D}}$. It publishes the public key ${pk}_{\st\mathcal {D}}$ and sends ${sk}_{\st\mathcal {D}}$ to the rest of arbiters.
\end{enumerate}

%(1^{\st \lambda})\rightarrow k:=(sk_{\st\mathcal{D}}, pk_{\st\mathcal{D}})%

Let $sk:=(sk_{\st\mathcal{G}}, sk_{\st\mathcal{D}})$ and $pk:=(pk_{\st\mathcal{G}}, pk_{\st\mathcal{D}})$. Note, this   phase takes place only once for all customers.
\vspace{2mm}
\item\label{RCPoRP::Bank-side-Initiation} \underline{\textit{Bank-side Initiation}}. $\mathtt{bankInit}(1^{\st \lambda})\rightarrow (T, pp, \bm l)$

$\mathcal{B}$ takes the following steps. 
\begin{enumerate}

\item\label{RCPoRP::setup} picks   secret keys $\bar k_{\st 1}$ and $\bar k_{\st 2}$ for  symmetric key encryption scheme and  pseudorandom function $\mathtt{PRF}$ respectively. It  sets two private statements as $\pi_{\st 1}=\bar k_{\st 1}$ and $\pi_{\st 2}= \bar k_{\st 2}$.
%
\item\label{RCPoRP::set-qp}  calls $\mathtt{SAP.init}(1^{\st\lambda}, adr_{\st\mathcal{B}}, adr_{\st\mathcal{C}}, \pi_{\st i})\rightarrow(r_{
\st i}, g_{\st i}, adr_{\st\text{SAP}})$ to initiate  agreements on  statements $\pi_{\st i}\in \{\pi_{\st 1}, \pi_{\st 2}\}$  with customer $\mathcal{C}$.  Let $T_{\st i}:=(\ddot{\pi}_{\st i}, g_{\st i})$ and $T:=(T_{\st 1}, T_{\st 2})$,  where  $\ddot{\pi}_{\st i}:=(\pi_{\st i}, r_{\st i})$ is the opening of $g_{\st i}$.  It also sets parameter $\Delta$ as a time window between two specific time points, i.e., $\Delta=t_{\st i} - t_{\st i-1}$. Briefly, it is used to impose an upper bound on a message delay.  %It  constructs a vector, $\bm{x}$, of three non-zero distinct $x$-coordinates, i.e., $\bm{x}=[x_{\st 1},..., x_{\st 3}]$, where $x_{\st i}\in \mathbb{F}_{\st p}$.
%
\item sends $\ddot{\pi}:=(\ddot{\pi}_{\st 1}, \ddot{\pi}_{\st 2})$ to   $\mathcal{C}$ and   sends  public parameter $pp:=(adr_{\st\text{SAP}},\Delta)$ to  smart contract $\mathcal{S}$.
%
\end{enumerate}


\vspace{2mm}
\item \underline{\textit{Customer-side Initiation}}\label{RCSP::Server-side-Initiation}. $\mathtt{customerInit} (1^{\st \lambda}, T, pp)\rightarrow a$

$\mathcal{C}$ takes the following steps. 

\begin{enumerate}
%
\item calls   $\mathtt{SAP.agree}(\pi_{\st i}, r_{\st i}, g_{\st i}, adr_{\st\mathcal{B}}, adr_{\st\text{SAP}})\rightarrow (g'_{\st i}, b_{\st i})$, to check the correctness of parameters in $T_{\st i}\in T$ and (if accepted) to agree on these parameters, where $(\pi_{\st i}, r_{\st i}) \in \ddot{\pi}_{\st i}\in T_{\st i}$ and $1\leq i \leq 2$. Note,  if both $\mathcal{B}$ and $\mathcal{C}$ are honest, then $g_{\st i}=g'_{\st i}$. It also checks $\Delta$ in  $\mathcal{S}$, e.g., to see whether it is sufficiently large.
%
\item if the above checks fail,  it sets $a=0$. Otherwise, it sets $a=1$. It sends $a$ to $\mathcal{S}$. 
\end{enumerate}
%
\vspace{2mm}
\item \underline{\textit{Generating  Update Request}}. $\mathtt{genUpdateRequest}(T, f, {\bm l})\rightarrow \hat m^{\st\mathcal{(C)}}_{\st 1}$

$\mathcal{C}$ takes the following steps. 

\begin{enumerate}
%
\item sets the inputs of algorithm $\mathcal{I}\in \{\mathtt{setupNewPayee}(.), $ $ \mathtt{ammendExistingPayee}(.)\}$ as below. 
%
\begin{itemize}

\item[$\bullet$] if $\mathtt{setupNewPayee}(.)$ is called, then it sets $m_{\st 1}^{\st(\mathcal C)}:=(\phi,f)$, where $f$ is new payee's detail.  %In this case, $\mathcal{S}$ appends $p$ to the payee list, $l$. 
%
\item[$\bullet$] if $\mathtt{ammendExistingPayee}(.)$  is called, then it sets $m_{\st 1}^{\st(\mathcal C)}:=(i, f)$, where $i$ is the index of the element in $\bm l$ that should be changed to $f$.  %In this case, $\mathcal{S}$ replaces $i$-th emement of $l$ with $p$, i.e., $l[i]=p$.

\end{itemize}
\item at time $t_{\st 0}$, sends to $\mathcal{S}$  the encryption of $m_{\st 1}^{\st(\mathcal C)}$, i.e., $\hat m_{\st 1}^{\st(\mathcal C)}=\mathtt{Enc}(\bar k_{\st 1}, m_{\st 1}^{\st(\mathcal C)})$. 
\end{enumerate}
%
% Inserting New Payee
\vspace{2mm}
 \item \underline{\textit{Inserting New Payee}}. $\mathtt{insertNewPayee}(\hat m^{\st\mathcal{(C)}}_{\st 1}, {\bm l})\rightarrow {\hat{\bm l}}$
 
$\mathcal{S}$ takes the following steps. 
  %
 \begin{itemize}
 %
 \item[$\bullet$] if $\hat m_{\st 1}^{\st(\mathcal C)}$  is not empty, it appends $\hat m_{\st 1}^{\st(\mathcal C)}$ to the payee list $\hat{\bm l}$, resulting an updated list, $\hat{\bm l}$. 
 %
  \item[$\bullet$] if $\hat m_{\st 1}^{\st(\mathcal C)}$ is empty,  it does nothing. 
  %
 \end{itemize}
 
 


 % Generating Warning
 \vspace{2mm}
\item \underline{\textit{Generating Warning}}. $\mathtt{genWarning}(T, {\hat{\bm l}}, aux)\rightarrow \hat m^{\st\mathcal{(B)}}_{\st1}$
%

$\mathcal{B}$ takes the following steps. 
\begin{enumerate}
%
\item  checks if the most recent list $\hat{\bm{l}}$ is not empty. If it is empty, it halts. Otherwise, it proceeds to the next step. 
%
\item  decrypts each element of $\hat{\bm l}$ and checks their correctness, e.g., checks whether each element meets its internal policy or CoP requirements stated in $aux$. If the check passes, it sets $m_{\st 1}^{\st(\mathcal{B})}= \text{``pass''}$. Otherwise, it sets $m_{\st 1}^{\st(\mathcal{B})}=\text{warning}$, where $\text{warning}$ is a  string that contains a warning's detail concatenated with the string $\text{``warning''}$.
%
\item at time $t_{\st 1}$, sends to $\mathcal{S}$ the encryption of $m_{\st 1}^{\st(\mathcal{B})}$, i.e.,  $\hat m_{\st 1}^{\st(\mathcal{B})}= \mathtt{Enc}(\bar k_{\st 1}, m_{\st 1}^{\st(\mathcal B)})$. 
\end{enumerate}


\vspace{2mm}
\item\label{clinet-at-T2} \underline{\textit{Generating Payment Request}}. $\mathtt{genPaymentRequest}(T, in_{\st f}, \hat{\bm{l}}, \hat m^{\st\mathcal{(B)}}_{\st1})\rightarrow \hat m^{\st\mathcal{(C)}}_{\st2}$

$\mathcal{C}$ takes the following steps. 
\begin{enumerate}
%
\item at time $t_{\st 2}$, decrypts the content of $\hat{\bm{l}}$ and $\hat m_{\st 1}^{\st(\mathcal{B})}$.  It sets a payment request $m_{\st 2}^{\st(\mathcal C)}$ to  $\phi$ or  $in_{\st f}$, where $in_{\st f}$ contains the payment's detail, e.g., the payee's detail in $\bm l$ and the amount it wants to transfer. 
%
\item at time $t_{\st 3}$, sends  to $\mathcal{S}$ the encryption of $m_{\st 2}^{\st(\mathcal C)}$, i.e., $\hat m_{\st 2}^{\st(\mathcal{C})}= \mathtt{Enc}(\bar k_{\st 1}, m_{\st 2}^{\st(\mathcal C)})$.
\end{enumerate}
%
\vspace{2mm}
\item \underline{\textit{Making Payment}}. $\mathtt{makePayment}(T, \hat m^{\st\mathcal{(C)}}_{\st2})\rightarrow \hat m^{\st\mathcal{(B)}}_{\st2}$

$\mathcal{B}$ takes the following steps. 
\begin{enumerate}
%
 \item at time $t_{\st 4}$, decrypts  the content of $\hat m_{\st 2}^{\st(\mathcal C)}$, i.e.,  $ m_{\st 2}^{\st(\mathcal{C})}= \mathtt{Dec}(\bar k_{\st 1}, \hat m_{\st 2}^{\st(\mathcal C)})$.
 %
 \item at time $t_{\st 5}$, checks the content of $m_{\st 2}^{\st(\mathcal C)}$. If $m_{\st 2}^{\st(\mathcal C)}$ is non-empty, i.e., $m_{\st 2}^{\st(\mathcal C)}=in_{\st f}$, it checks if the payee's detail in $in_{\st f}$ has already been checked and the payment's amount does not exceed the customer's credit. If the checks pass, it  runs the off-chain payment algorithm, $\mathtt{pay}(in_{\st f})$.  In this case, it sets $m_{\st 2}^{\st(\mathcal B)}$=``paid''. Otherwise (i.e., if $m_{\st 2}^{\st(\mathcal C)}=\phi$ or neither checks pass), it sets $m_{\st 2}^{\st(\mathcal B)}=\phi$. It sends  to $\mathcal{S}$ the encryption of  $m_{\st 2}^{\st(\mathcal B)}$, i.e., $\hat m_{\st 2}^{\st(\mathcal{B})}= \mathtt{Enc}(\bar k_{\st 1}, m_{\st 2}^{\st(\mathcal B)})$.  %Otherwise (i.e., if $m_{\st 2}^{\st(\mathcal C)}=\phi$ or neither checks pass),  it halts.
 %
\end{enumerate}
%
\vspace{2mm}
\item  \underline{\textit{Generating Complaint}}. $\mathtt{genComplaint}(\hat m^{\st\mathcal{(B)}}_{\st 1}, \hat m^{\st\mathcal{(B)}}_{\st2}, T, pk, {aux}_{\st f})\rightarrow  (\hat z, \hat{\ddot \pi})$

$\mathcal{C}$ takes the following steps. 
\begin{enumerate}
%
\item\label{DR::C-sends-complaint} decrypts $ \hat m^{\st\mathcal{(B)}}_{\st 1}$ and $\hat m^{\st\mathcal{(B)}}_{\st2}$; this results in $  m^{\st\mathcal{(B)}}_{\st 1}$ and $ m^{\st\mathcal{(B)}}_{\st2}$ respectively. Depending on the content of  the decrypted values, it sets its complaint's parameters $z:=(z_{\st 1}, z_{\st 2}, z_{\st 3})$ as follows.  %sends a complaint: $z:=(k, x, y)$ to $\mathcal{S}$ at time $T_{\st 6}$, where $k, x$ and $y$ are   set as follows.  

\begin{itemize}
%
%\item  [$\bullet$] if $\mathcal{C}$ want to complain that $\mathcal{B}$ has not provided any message (i.e., neither pass nor warning) and 
%
 \item  [$\bullet$] if $\mathcal{C}$ want to make one of the two below statements, it sets  $z_{\st 1}=$``challenge message".
 
 \begin{enumerate}[label=(\roman*)]
  \item the ``pass'' message (in $m^{\st\mathcal{(B)}}_{\st 1}$)  should have been a warning.
  
 \item $\mathcal{B}$ has not provided any message (i.e., neither pass nor warning)   and if $\mathcal{B}$  provided a warning  then  the fraud would have been  prevented.  
 

   \end{enumerate}
   \item [$\bullet$] if $\mathcal{C}$ wants to challenge the effectiveness of the warning (in $m^{\st\mathcal{(B)}}_{\st 1}$),  it sets $z_{\st 2}= m||sig||pk_{\st\mathcal{G}}||$ $\text{``challenge warning''}$, where  $m$ is an evidence,   $sig\in aux_{\st f}$ is the evidence's  certificate (obtained from the certificate generator $\mathcal{G}$), and $pk_{\st\mathcal{G}}\in pk$.  
 
  % $x =$ ``challenge warning''. 

 %
  \item [$\bullet$] if $\mathcal{C}$ wants to complain about the inconsistency of the payment (in $m^{\st\mathcal{(B)}}_{\st 2}$), then it sets  $z_{\st 3} =$ ``challenge payment''. Otherwise, it sets $
z_{\st 3}=\phi $.

    \end{itemize}
    \item at time $t_{\st 6}$, sends to $\mathcal{S}$ the following values: 
    
    \begin{itemize}
     \item[$\bullet$] the encryption of complaint $z$, i.e.,   $\hat z= \mathtt{Enc}(\bar k_{\st 1}, z)$.
     \item[$\bullet$] the encryption of $\ddot{\pi}:=(\ddot{\pi}_{\st 1}, \ddot{\pi}_{\st 2})$, i.e., $\hat{\ddot \pi}=\mathtt{\tilde{Enc}}({pk}_{\st\mathcal {D}}, \ddot \pi)$. Note, $\ddot \pi$ contains the openings of the private statements' commitments (i.e., $g_{\st 1}, g_{\st 2}$), and is encrypted under each $\mathcal{D}_{\st j}$'s public key. 
     \end{itemize}
\end{enumerate}


%\item\label{VerifyingComplaint}  \underline{\textit{Verifying Complaint}}. $\mathtt{verComplaint}(\hat z, \hat{\ddot{\pi}}, g, \hat m^{\st\mathcal{(C)}}_{\st1},\hat m^{\st\mathcal{(C)}}_{\st 2}, \hat m^{\st\mathcal{(B)}}_{\st1}, \hat m^{\st\mathcal{(B)}}_{\st 2}, \hat{\bm{l}},  j, {sk}_{\st\mathcal {D}}, aux, pp)\rightarrow \hat{\bm w}_{\st j}$

\vspace{2mm}
\item\label{VerifyingComplaint}  \underline{\textit{Verifying Complaint}}. $\mathtt{verComplaint}(\hat z, \hat{\ddot{\pi}}, g, \hat {\bm m}, \hat{\bm{l}},  j, {sk}_{\st\mathcal {D}}, aux, pp)\rightarrow \hat{\bm w}_{\st j}$

Every Arbiter, $\mathcal{D}_{\st j}\in\{\mathcal{D}_{\st 1}, ..., \mathcal{D}_{\st n}\}$, takes the following steps.
\begin{enumerate}

%
\item at time $t_{\st 7}$, decrypts $\hat{\ddot{\pi}}$, i.e., ${\ddot{\pi}}=\mathtt{\tilde{Dec}}({sk}_{\st\mathcal {D}}, \hat{\ddot \pi})$. 

\item checks the validity  of $(\ddot{\pi}_{\st 1}, \ddot{\pi}_{\st 2})$ in $\ddot{\pi}$ by locally running  the SAP's verification, i.e., $\mathtt{SAP.verify}(.)$, for each  $\ddot{\pi}_{\st i}$. It   returns  $s$. If $s=0$, it halts. If $s=1$ for both $\ddot{\pi}_{\st 1}$ and  $\ddot{\pi}_{\st 2}$, it proceeds to the next step. 
%
%\item decrypts $\hat m^{\st\mathcal{(C)}}_{\st1}$ and $\hat m^{\st\mathcal{(C)}}_{\st 2}$ and checks if they are not empty. Also, it checks if 
%%%%%%%%%%%%
\item decrypts $\hat{\bm m}=[\hat{m}_{\st 1}^{\st(\mathcal C)}$, $\hat{m}_{\st 2}^{\st(\mathcal C)}, \hat{m}_{\st 1}^{\st(\mathcal B)}, \hat{m}_{\st 2}^{\st(\mathcal B)}]$  using $\mathtt{Dec}(\bar k_{\st 1},.)$, where $\bar k_{\st 1}\in\ddot \pi_{\st 1}$. Let $[{m}_{\st 1}^{\st(\mathcal C)},  {m}_{\st 2}^{\st(\mathcal C)},  {m}_{\st 1}^{\st(\mathcal B)}, {m}_{\st 2}^{\st(\mathcal B)}]$ be the result. 

\item  checks whether $\mathcal C$ made an update request to its payee's list. To do so, it checks if  $m_{\st 1}^{\st(\mathcal C)}$  is non-empty and (its encryption) was registered by $\mathcal{C}$ in $\mathcal{S}$. Also, it checks whether $\mathcal C$ made a payment request, by checking if $m_{\st 2}^{\st(\mathcal C)}$ is non-empty and (its encryption) was registered by $\mathcal{C}$ in $\mathcal{S}$ at time $t_{\st 3}$.  If either check fails, it halts. 
%%%%%%%%%%%%
\item decrypts $\hat z$ and $\hat{\bm{l}}$ using $\mathtt{Dec}(\bar k_{\st 1},.)$, where $\bar k_{\st 1}\in\ddot \pi_{\st 1}$. Let $ z:=(z_{\st 1}, z_{\st 2}, z_{\st 3})$ and ${\bm{l}}$ be the result. 
%
\item\label{arbiters-verdict} sets its verdicts according to  the content of  $z:=(z_{\st 1}, z_{\st 2}, z_{\st 3})$, as follows.  
%
\begin{itemize}

%
\item[$\bullet$]  if  ``challenge message'' $\notin z_{\st 1}$, it sets $w_{\st 1,j}= 0$. Otherwise,  it runs $\mathtt{verStat}(add_{\st\mathcal{S}}, m_{\st 1}^{\st(\mathcal{B})},  \bm{l}, \Delta, {aux})\rightarrow w_{\st 1, j}$, to determine if a warning (in $m_{\st 1}^{\st(\mathcal{B})}$) should have been given (instead of the ``pass'' or no message). %It sends $d_{\st i}$ to $\mathcal{S}$, at time $T_{\st 8}$. %If  $k=\phi$, then it does nothing  in this step.
%
\item[$\bullet$]  if ``challenge warning'' $\notin z_{\st 2}$, it sets $w_{\st 2, j}= w_{\st 3, j}= 0$. Otherwise, it runs $\mathtt{checkWarning}(add_{\st\mathcal{S}}, z_{\st 2}, m_{\st 1}^{\st(\mathcal{B})},$ $  {aux}')\rightarrow (w_{\st 2, j}, w_{\st 3, j})$, to determine the effectiveness of the warning (in $m_{\st 1}^{\st(\mathcal{B})}$). %It sends $(v_{\st i}, \bar v_{\st i})$ to $\mathcal{S}$, at time $T_{\st 9}$.



\item[$\bullet$]  if ``challenge payment'' $\in z_{\st 3}$, it checks whether the  payment has been  made.   If the check passes, it sets  $w_{\st 4, j}=1$. If the check fails,   it sets $w_{\st 4, j}=0$.  If ``challenge payment'' $\notin z_{\st 3}$, it checks if  ``paid'' is in ${m}_{\st 2}^{\st(\mathcal C)}$. If the check passes, it sets $w_{\st 4, j}=1$. Otherwise, it sets $w_{\st 4, j}=0$. 
%
\end{itemize}
%
\item  encodes  its verdicts $(w_{\st 1, j}, w_{\st 2, j}, w_{\st 3, j},  w_{\st 4, j})$ as follows. 
%
\begin{enumerate}
%
\item locally maintains a counter, $o_{\st adr_{\st{c}}}$,  for each $\mathcal{C}$. It sets its initial value to $0$.
%

%\item calls $\mathtt{PVE}(.)$ to represent every verdict as a polynomial. In particular, it performs as follows. $\forall i, 1\leq i \leq 4:$

\item calls $\mathtt{PVE}(.)$ to encode each verdict. In particular, it performs as follows. $\forall i, 1\leq i \leq 4:$
\begin{enumerate}
%

\item[$\bullet$] calls $\mathtt{PVE}(\bar{k}_{\st 0}, adr_{\st\mathcal{C}},  w_{\st i, j}, o_{\st adr_{\st{c}}}, n,  j)\rightarrow  \bar{  w}_{\st i,j}$

%\item[$\bullet$] calls $\mathtt{PVE}(\bar{k}_{\st 0}, adr_{\st\mathcal{C}}, w_{\st i, j}, n, \bm x, \textit{offset}_{\st adr_{\st{c}}}, j)\rightarrow  \bar{\bm w}_{\st i,j}$.
%
\item[$\bullet$] $o_{\st adr_{\st{c}}}=o_{\st adr_{\st{c}}}+1$.
%
\end{enumerate}
By the end of this step, a vector ${\bar {\bm w}}_{\st j}$ of four encoded verdicts is computed, i.e., $\bar {\bm w}_{\st j}=[ \bar{  w}_{\st 1,j},..., \bar{  w}_{\st 4,j}]$.
%
\item uses $\bar k_{\st 2}\in \ddot \pi_{\st 2}$ to further encode/encrypt  $\mathtt{PVE}(.)$'s outputs as follows. %$\forall i, 1\leq i \leq 4:$
%
$ \hat {\bm w}_{\st j}= \mathtt{Enc}(\bar k_{\st 2}, \bar{\bm w}_{\st j})$.


%\
%
%
%\
%
%\item\label{call-ZPVG} generates $4$  pseudorandom values, by calling $\mathtt{ZPVG}(\bar{k}_{\st 0}, adr_{\st\mathcal{C}}, n,  4, j)\rightarrow \bm{r}_{\st j}$. Recall, the sum of each element $ r_{\st i,j}\in \bm r_{\st j}$ and the other arbiters' related values would be $0$.   
%%
%\item\label{derive-PR-from-k2} generates $4$  pseudorandom values using $\bar k_{\st 2}$ (where  $\bar k_{\st 2}\in  \ddot\pi$) as follows. 
%%
%$$\forall i, 1\leq i \leq 4: \alpha_{\st i} = \mathtt{PRF}(\bar k_{\st 2}, i)$$
%
% Note, all arbiters would generate the same set of $\alpha_{\st i}$. 
%
%\item  encodes  each $w_{\st i,j}$ by using the values generated in steps \ref{call-ZPVG} and \ref{derive-PR-from-k2}, as follows. 
%%
% $$\forall i, 1\leq i \leq 4: \hat w_{\st i, j} = \big(\alpha_{\st i}\cdot w_{\st i, j}+r_{\st i, j}\big)\bmod p$$
\end{enumerate}


%%. 
%\item[$\bullet$]  if  ``challenge message'' $\in k$, then it runs $\mathtt{verStat}(add_{\st\mathcal{S}}, m_{\st 1}^{\st(\mathcal{B})}, T, l', \text{aux})\rightarrow d_{\st i}$ to determine whether a warning should have been given (instead of the ``pass'' or no message).  It sends $d_{\st i}$ to $\mathcal{S}$, at time $T_{\st 8}$. %If  $k=\phi$, then it does nothing  in this step.
%%
%\item[$\bullet$]  if  ``challenge warning'' $\in x$, then it runs $\mathtt{checkWarEff}(add_{\st\mathcal{S}}, x, m_{\st 1}^{\st(\mathcal{B})},  \text{aux}')\rightarrow (v_{\st i}, \bar v_{\st i})$ to determine the warning's effectiveness.  It sends $(v_{\st i}, \bar v_{\st i})$ to $\mathcal{S}$, at time $T_{\st 9}$.
%
%
%
%
%\item[$\bullet$]  if $y =$ ``challenge payment'', in the case where the payment has been  made,  it sets its  verdict $w_{\st i}$ to $1$; otherwise, it sets $w_{\st i}$ to $0$. It sends $w_{\st i}$ to $\mathcal{S}$, at time $T_{\st 10}$.  %If  $y=\phi$, then it does nothing  in this step.


\item at time $t_{\st 8}$, sends to $\mathcal S$ the encrypted vector, $\hat {\bm w}_{\st j}$. %=[\hat { w}_{\st 1, j}, \hat {  w}_{\st 2, j}, \hat {  w}_{\st 3, j}, \hat {  w}_{\st 4, j}]$.
\end{enumerate}


\vspace{2mm}
\item\label{DR::DisputeResolution}  \underline{\textit{Resolving Dispute}}. $\mathtt{resDispute}(T_{\st 2}, \hat {\bm w}, pp)\rightarrow \bm v$



 $\mathcal{DR}$ takes the below steps at time $t_{\st 9}$, when it is invoked by $\mathcal{C}$ or  $\mathcal{S}$ which sends $\ddot\pi_{\st 2}\in T_{\st 2}$ to it.

\begin{enumerate}
%
\item checks the validity of $\ddot{\pi}_{\st 2}$ by locally running  the SAP's verification, i.e., $\mathtt{SAP.verify}(.)$, that  returns  $s$. If $s=0$, it halts. Otherwise, it proceeds to the next step. 
%
%\item decrypts $\hat{m}_{\st 1}^{\st(\mathcal C)}$, $\hat{m}_{\st 2}^{\st(\mathcal C)}$, and $\hat{m}_{\st 2}^{\st(\mathcal B)}$  using $\mathtt{Dec}(\bar k_1,.)$, where $\bar k_1\in\ddot \pi$. Let ${m}_{\st 1}^{\st(\mathcal C)}$,  ${m}_{\st 2}^{\st(\mathcal C)}$, and ${m}_{\st 2}^{\st(\mathcal B)}$ be the result respectively. 
%
%\item\label{DR::check-m1c}  checks whether $\mathcal C$ made an update request to its payee's list. To do so, it checks if  $m_{\st 1}^{\st(\mathcal C)}$  is non-empty and (its encryption) was registered by $\mathcal{C}$ in $\mathcal{S}$.
%
%\item\label{DR::check-payment-request}  checks whether $\mathcal C$ made a payment request, by checking if $m_{\st 2}^{\st(\mathcal C)}$ is non-empty and (its encryption) was registered by $\mathcal{C}$ in $\mathcal{S}$ at time $t_{\st 3}$.  

\item computes the final verdicts, as below. 
%
\begin{enumerate}
%
\item uses $\bar k_{\st 2}\in \ddot \pi_{\st 2}$ to decrypt the arbiters' encoded verdicts, as follows. $ \forall j, 1\leq j \leq n:$

$ \bar {\bm w}_{\st j}= \mathtt{Dec}(\bar k_{\st 2}, \hat{\bm w}_{\st j})$, where $\hat{\bm w}_{\st j}\in \hat{\bm w}$.
 % 
 \item constructs four vectors, $[\bm u_{\st 1},...,\bm u_{\st 4}]$, and sets  each vector $\bm u_{\st i}$ as follows. $\forall i, 1\leq i \leq 4:$
 
  $\bm u_{\st i}=[\bar{w}_{\st i,1},...,\bar{w}_{\st i,n}]$, where $\bar{w}_{\st i,j}\in \bar {\bm w}_{\st j}$. 
% $\forall i, 1\leq i \leq 4: \bar {\bm w}_{\st i,j}= \mathtt{Dec}(\bar k_{\st 2}, \hat{\bm w}_{\st i,j})$.
%
\item calls $\mathtt{FVD}(.)$ to extract each final verdict, as follows. $\forall i, 1\leq i \leq 4:$ calls $\mathtt{FVD}(n,  {\bm u}_{\st i})\rightarrow  v_{\st i}$. 


%$\mathtt{FVD}(n,   \bm x, \bar{\bm w})\rightarrow  w$


%regenerates $4$  pseudorandom values using $\bar k_{\st 2}$ (where  $\bar k_{\st 2}\in  \ddot\pi$) as follows. 
%
%$$\forall i, 1\leq i \leq 4: \alpha_{\st i} = \mathtt{PRF}(\bar k_{\st 2}, i)$$
%
%\item  extracts the decoded final verdict (for each $i$) as follows. 
%
% $$\forall i, 1\leq i \leq 4: v_{\st i} = \big((\alpha_{\st i})^{\st -1} \cdot \sum\limits_{\st j=1}^{\st n} \hat {w}_{\st i, j}\big)\bmod p= \sum\limits_{\st j=1}^{\st n} {w}_{\st i, j}$$
%
\end{enumerate}
%

\item outputs $\bm v=[v_{\st 1},...,v_{\st 4}]$.

\end{enumerate}
\end{enumerate}
Customer $\mathcal{C}$ must be reimbursed if the final verdict is that (i)  the ``pass'' message or  missing message should have been a warning or (ii)  the warning was ineffective and the provided evidence was not invalid, and (iii) the payment has been made. Stated formally, the following relation must hold: 
%
\begin{center}
$\Big( \underbrace{(v_{\st 1}=1)}_{\st (\text{i})}\vee  \underbrace{(v_{\st 2}=1\ \wedge\ v_{\st 3}=1)}_{\st (\text {ii})}\Big)\wedge\Big(\underbrace{v_{\st 4}=1}_{\st (\text{iii})}\Big)$.
\end{center}
%
 %where $v_{\st i}\in \bm v$.
%
%\begin{enumerate}
%\item\label{DR::check-warning-related-message}   one of the following  warning-related conditions holds.
%%
%\begin{enumerate}
%%
%\item the final verdict is that the ``pass'' message or a missing message should have been a warning. To do so, it checks  if $v_{\st 1}=0$.
%%
%\item the final verdict is that the warning was ineffective and the provided evidence was not invalid, by checking  if $v_{\st 2}=0$ and $v_{\st 3}=1$. 
%%
%\end{enumerate}
%%
%\item\label{DR::check-payment-related-conditions}  checks if the following  payment-related condition holds.
%%
%\begin{enumerate}
%%
%\item[$\bullet$] the final verdict is that the payment has been made, by checking if $v_{\st 4}=1$. 
%%
%\item  the encryption of  ``paid'' (in ${m}_{\st 2}^{\st(\mathcal C)}$) was registered by $\mathcal{S}$ at time $t_{\st 5}$.
%



%If  the above conditions  in steps  \ref{DR::check-warning-related-message} and \ref{DR::check-payment-related-conditions} hold,  it outputs $1$. Otherwise, it outputs $0$. 
%\end{enumerate}
%\end{enumerate}



Note that in the above PwDR protocol, even $\mathcal{C}$ and $\mathcal{B}$ that know the decryption secret keys, $(\bar k_{\st 1}, \bar k_{\st 2})$, cannot link a certain verdict to an arbiter, for two main reasons; namely,  (a) they do not know the masking random values used by arbiters to mask each verdict and (b) the final verdicts $(v_{\st 1},..., v_{\st 4})$ reveal nothing about the number of $1$ or $0$ verdicts, except when all arbiters vote $0$.  We highlight that we used PVE and FVD in the PwDR protocol only because they are highly efficient. However, it is easy to replace them with GPVE and GFVD, e.g., when the required threshold is greater than one. 



\begin{theorem}\label{theorem::PwDR-security}
The above PwDR scheme is secure, with regard to definition \ref{def::PwDR-security}, if the digital signature is existentially unforgeable under chosen message attacks,  the blockchain, SAP, and pseudorandom function $\mathtt{PRF}(.)$ are secure, and the encryption schemes are semantically secure. 
\end{theorem}


\input{proof}

%\subsection{Extensions}
%
%\subsubsection{Micro-enterprise or Charity Customer.} There is a clause in the CRM code that  allows a bank to refuse reimbursing a victim of an APP scam, if (i) the victim is an organisation (i.e., Micro-enterprise or Charity), (ii) the organisation has internal payment procedures that are effective in preventing the APP scam, and (iii) the victim has not followed those procedures. Below, we outline how the PwDR protocol can be extended to capture these requirements. The modified PwDR allows a customer to prove it has followed those requirements (or to prove there were not such  procedures), which ultimately benefits an honest customer during the dispute resolution phase (i.e., phase \ref{DR::DisputeResolution}).   We present the extension in two phases. In phase I, we provide a subprotocol that determines whether the customer has met the above requirements. In phase II, we show how the subprotocol can be integrated into the PwDR protocol.  
%
%\noindent\textit{{Phase I.}} In this phase, we provide an overview of a  subprotocol that determines if the customer has met the above requirements. At a high level, this subprotocol works as follows.
%
%
% \begin{enumerate}[label=(\Alph*)]
%\item\label{C-side} $\mathcal{C}$ sends the organisation's internal procedure specification and the specification's certificate  to  $\mathcal{S}$. Moreover,   it sends to $\mathcal{S}$  a proof, $p$, asserting that it has followed the above procedure. 
%
%\item\label{D-side} Every  $\mathcal{D}_{\st i}$ takes the following steps:
% 
% \begin{enumerate}
% \item checks the certificate by running procedure $\mathtt{Sig.ver}(.)\rightarrow h_{\st i}$. It sends $h_{\st i}$ to $\mathcal{S}$. It waits until all arbiters provide their inputs. Then, it locally runs $\mathtt{f.verdict}(h_{\st 1},...,h_{\st n})$ to determine if the certificate has been approved (by the majority of arbiters). It only proceeds to the next step if $\mathtt{f.verdict}(.)$ returns $1$.  
%%
% \item\label{subprotocol::evaluate-procedure}  checks whether the  procedure could prevent the APP scam. If the check passes, then it sends $v'_{\st i}=1$  to $\mathcal{S}$; otherwise, it sends $v'_{\st i}=0$  to $\mathcal{S}$. Again, it waits until all arbiters provide their inputs. Next, it locally runs $\mathtt{f.verdict}(v'_{\st 1},...,v'_{\st n})$. It only proceeds to the next step if $\mathtt{f.verdict}(.)$ returns $1$.
% %
% \item verifies  proof $p$. If the check passes, then it sends $v''_{\st i}=1$  to $\mathcal{S}$. Otherwise, it sends $v'_{\st i}=0$  to $\mathcal{S}$.
% 
% \end{enumerate} 
% 
%\item\label{S-side} $\mathcal{S}$ computes and stores the following values:
%  \begin{itemize}
%  %
%  \item [$\bullet$] $h=\mathtt{f.verdict}(h_{\st 1},...,h_{\st n})$.
%  %
%  \item [$\bullet$] if $h=1$, then $v'=\mathtt{f.verdict}(v'_{\st 1},...,v'_{\st n})$.
%  %
%  \item [$\bullet$] if $v'=1$, then $v''=\mathtt{f.verdict}(v''_{\st 1},...,v''_{\st n})$.
%   \item [$\bullet$] sets $g=1$, if one of the  following two conditions holds:  
%   
%   \begin{itemize}
%   \item[*]  $h=0$.
%   \item[*]   $h\wedge v'' =1$.
%  \end{itemize}
% otherwise (if neither condition holds), sets $g=0$. 
%  %
%   \end{itemize} 
% \end{enumerate} 
% 
%% checks whether the  certificate is valid and the procedure could prevent the APP scam. If both checks pass, then $\mathcal{D}_{\st i}$ sends $v'_{\st i}=1$  to $\mathcal{S}$. Otherwise, it sends $v'_{\st i}=0$ to it. Furthermore, in the case where $\mathcal{D}_{\st i}$  sent $v'_{\st i}=1$ to $\mathcal{S}$, it  checks $p$'s validity. If the check passes, then it sends $v''_{\st 1}=1$ to $\mathcal{S}$; if the check fails, it sends $v''_{\st 1}=0$ to $\mathcal{S}$. In the case where 
%%
%%
%%After all arbiters provide their inputs, $\mathcal{S}$ executes    $\mathtt{effective}(v'_{\st 1}, ..., v'_{\st n})\rightarrow b'$ and   $\mathtt{effective}(v''_{\st 1}, ..., v''_{\st n})\rightarrow b''$. 
%
%%
%%Next $\mathcal{C}$ checks $b'$, if it has been set to $1$, then it sends to $\mathcal{S}$  a proof, $p$, asserting that it has followed the above procedure. Otherwise (i.e., $b'=0$), it does not need to send any proof; note that in this case the arbiters reaches to the consensus that there was not effective internal procedure to prevent the APP scam. Given the customer's input, every  arbiter $\mathcal{D}_{\st i}$ checks the proof's validity. If the check passes, then it sends $v''_{\st 1}$ to $\mathcal{S}$; otherwise, it sends $v''_{\st 1}$ to $\mathcal{S}$. Once all arbiter's inputs are provided,  $\mathcal{S}$ runs $\mathtt{effective}(v''_{\st 1}, ..., v''_{\st n})\rightarrow b''$. 
%
%
%
%\noindent\textit{{Phase II.}} Now describe how the  above subprotocol's phases can be integrated into  the PwDR protocol.  First,  phases \ref{C-side} and \ref{D-side},  of the subprotocol, are added to steps \ref{DR::C-sends-complaint} and \ref{arbiters-verdict}, of the PwDR protocol, respectively. Second, the checks in phase \ref{DR::check-m1c}  of the PwDR protocol need to also ensure that $g=1$, by taking the steps of  phase \ref{S-side}   in the subprotocol. 
%
%
%Note that in step \ref{subprotocol::evaluate-procedure} of the subprotocol, it is assumed that each arbiter uses a well-defined process to evaluate whether the customer's internal payment procedures could have prevented the APP scam. Nevertheless,  effective   payment procedures that  prevent the APP fraud have not been appropriately defined  by the CRM code. This leads to a  manual and inefficient evaluation process.    Therefore, one may ask:
%
%
%
%\stepcounter{counter}
%%\arabic{counter}
%
%
%
%
%  \begin{center}\textit{Q\arabic{counter}: which measures exactly should be included in the internal payment procedures of an organisation to prevent  APP scams?}
% \end{center}
% 
%Given an explicit list of payment procedures  that  prevent  APP scams,  we could make the above evaluation procedure autonomous and transparent. In particular, such a list could be encoded into the  smart contract $\mathcal{S}$ which receives inputs from the customer (and possibly arbiters) and check if those internal payment procedures were effective in preventing the APP scam. 
%
%
%\subsubsection{Security against exploitative victim.}
%
%Having in place a transparent deterministic procedure (e.g.,  the PwDR protocol)  for evaluating victims' requests for reimbursement  could potentially create opportunities for exploitations. In particular, an honest victim  of the APP fraud who had been reimbursed in the past due to the payment system's vulnerability, e.g., ineffective payment, may be tempted to  exploit the same  known vulnerability multiple times.  Below, we outline two cases in which the malicious victim may exploit a known vulnerability and describe how they can be dealt with.  
%
%\begin{itemize}
%\item Case 1: A genuine victim, who  previously had been reimbursed,  colludes with a certain payee. In this case, the malicious victim uses the previous working strategy (e.g., the same certificates and complaints) to declare that it has been a victim of the APP fraud but this time it  exploits the weakness (e.g., ignores the ineffective warning). Note, the colluding payee acts exactly the same way as a real scammer does in the APP scam, e.g., after receiving the payment, it transfers the money to another account abroad. 
%
%
%\item Case 2: A genuine victim shares (or sells) its knowledge of the vulnerability to a  malicious customer who colludes with a payee to claim it has been a victim of the APP scam. Therefore, this case is similar to Case 1 with the main difference that the claimant's  identity  changes each time a claim is made. %which makes tracking the victim harder than the one in Case 1. 
%\end{itemize}
%
%
%Ideally, the bank should patch the vulnerability as soon as the first  incident occurs; however, this may not be the case in the real world as the cost of improving a  (payment) system to deal with such an incident may far exceed the  bank's monetary loss in that incident. Currently, neither the CRM code nor the ``Payment Services Regulations'' \cite{Regulations} explicitly offer any solution for the above cases.  To address the issue in Case 1, we propose the following remedy. First, we introduce two (set of) parameters; namely, threshold and counters. We let  bank $\mathcal{B}$  define the value of the threshold  in the smart contract, $\mathcal{S}$. Also, we require the protocol to keep track of the number of times the same customer is reimbursed for the same complaint, e.g., ineffective warning. Now we outline how these parameters can assist the  protocol to rectify the issue. Each time the protocol receives a customer's complaint, it checks whether  the total number of times the same customer is reimbursed for that specific  complaint exceeds the predefined threshold; if so, the protocol discards that complaint. Otherwise, it proceeds as before. More specifically, we amend the PwDR protocol as follows. 
%
%\begin{itemize}
%\item[$\bullet$]  $\mathcal{S}$ maintains a  counter vector, $\bm q^{\st (\mathcal{C})}=[(q_{\st e}, e),(q_{\st  x}, x),(q_{\st y}, y)]$,  for each customer $\mathcal{C}$, where  $q_{\st e}, q_{\st x}$, and $q_{\st y}$ are initially set to $0$ while $e, x$ and $y$ are the types of complaint, as they were defined in the PwDR scheme. 
%
%\item[$\bullet$]    $\mathcal{B}$ defines a fixed threshold $t$ in   $\mathcal{S}$,  where $t >1$. 
%
%\item[$\bullet$] In Phase \ref{DR::DisputeResolution}, $\mathcal{S}$ increments counter $q_{\st j}$ by $1$, each time   $\mathcal{C}$ is reimbursed for complaint $j$, where $j\in \{e,x,y\}$. 
%
%
%%\item[$\bullet$]   $\mathtt{verComplaint}(.)$,  $\mathtt{checkWarEff}(.)$, and $\mathtt{verStat}(.)$ take $\bm q^{\st (\mathcal{C})}$ and $t$ as inputs as well.  
%
%\item[$\bullet$]  Algorithm $\mathtt{verComplaint}(.)$ takes extra parameters $\bm q^{\st (\mathcal{C})}$ and $t$ as inputs.  
%
%
%\item[$\bullet$] In Phase \ref{VerifyingComplaint}, when a committee member, $\mathcal{D}_{\st i}$, wants to examine  $\mathcal{C}$'s  complaint, it reads the content of $\bm q^{\st (\mathcal{C})}$ and $t$ from $\mathcal{S}$ and passes them to $\mathtt{verComplaint}(.)$, which first checks whether the counter in $\bm q^{\st (\mathcal{C})}$ exceeds  $t$ for the complaint that $\mathcal{C}$ is making. If the check passes, it sets $d_{\st i}= v_{\st i}= \bar v_{\st i}=  w_{\st i}=\phi$ and outputs $(d_{\st i}, v_{\st i}, \bar v_{\st i},  w_{\st i})$ without requiring $\mathcal{D}_{\st i}$ to process $\mathcal{C}$'s claim. Otherwise,  $\mathcal{D}_{\st i}$ checks the claim as before.  
%
%\end{itemize}
%
%Now, we move on to the issue in Case 2 which is harder to identify than the one in Case 1. Because, in the former case, the identity of a malicious customer which wrongly claims that it has fallen victim to the APP fraud changes continuously and  is hardly distinguishable from a genuine victim without the assistance of extra information (e.g., phone records, emails) that is not trivial  to attain without  external intervention, e.g., a subpoena. To address this issue, we  propose the following mitigation.  Briefly, we require $\mathcal{B}$ to enhance its system and rectify the issue when the number of complaints related to the same issue exceeds a global threshold. Specifically, $\mathcal{B}$  defines in $\mathcal{S}$ a \emph{global} threshold $gt$ and global counter vector $\bm g=[(g_{\st e}, e),(g_{\st  x}, x),(g_{\st y}, y)]$,   where the vector's elements are defined the same way as those are defined in $\bm q$, with the difference that they are global and are not for a specific customer. Each time a customer is reimbursed for a reason   the related counter in $\bm g$ is incremented by $1$. When a counter exceeds the value of $gt$, $\mathcal{S}$ notifies $\mathcal{B}$ which patches the issue and then sets the related counter to $0$. Note that the value of $gt$ can be set such that when the monetary loss exceeds the upgrade costs, then  $\mathcal{B}$ upgrades the system.  










%$\bm q^{\st (\mathcal{C})}=[(q_{\st e}, e),(q_{\st  x}, x),(q_{\st y}, y)]$,  for each customer $\mathcal{C}$, where  $q_{\st e}, q_{\st x}$, and $q_{\st y}$ are initially set to $0$ while $e, x$ and $y$ are the types of complaint



%we can introduce a threshold for each vulnerability to the system. When it is exceeded, then that vulnerability needs to be dealt with (or in general the system should be upgraded).


%\section{Discussion}
% 
% 
% \subsection{Effective Warning}
%In the protocol, in step \ref{clinet-at-T2}, to which value  $\mathcal{C}$ sets its message $m_{\st 2}^{\st(\mathcal C)}$ is not totally deterministic  and depends on various (external) factors, e.g., warning effectiveness,  human factors. It is very  likely that  if $m_{\st 1}^{\st(\mathcal B)}=$ ``pass'', then $\mathcal{C}$ acts deterministically, by asking $\mathcal{B}$ to make the payment, i.e.,  $\mathcal{C}$ sets  $m_{\st 2}^{\st(\mathcal C)}=in_{\st p}$.   However,  to which value $\mathcal{C}$ sets $m_{\st 2}^{\st(\mathcal C)}$ when (a) $m_{\st 1}^{\st(\mathcal B)}= \text{warning}$ or (b) no message is provided by $\mathcal{B}$ at time $T_{\st 2}$, depends on many factors. For instance, if the warning is not effective and does not concern $\mathcal{C}$, then $\mathcal{C}$ still would  set    $m_{\st 2}^{\st(\mathcal C)}=in_{\st p}$. Similarly, if  $\mathcal B$ does not send $m_{\st 1}^{\st(\mathcal B)}$, it is still possible that $\mathcal{C}$ sets $m_{\st 2}^{\st(\mathcal C)}=in_{\st p}$, for instance when it is distracted and does not pay attention to the absence of  the message that was supposed to be provided by $\mathcal{B}$ on time. On the other hand, if the warning is effective, or $\mathcal{C}$ in general is highly sensitive to warnings and  the absence of $\mathcal B$'s message, then it  does not make any payment, i.e.,  it sets $m_{\st 2}^{\st(\mathcal C)}=\phi$. Despite the above challenges, the proposed protocol ensures that $\mathcal{C}$ will be identified as the party who should be reimbursed,  if it acts according to the protocol, makes a payment but the warning was ineffective or no message was provided by $\mathcal{B}$ in step \ref{clinet-at-T2}. Therefore, the following questions would  follow: 
%
%\stepcounter{counter}
%%\arabic{counter}
%
%  \begin{center}\textit{Q\arabic{counter}: what percentage of customers after encountering the warning do still proceed to make a payment (i.e., set $m_{\st 2}^{\st(\mathcal C)}=in_{\st p}$)?}
%\end{center}
%
%\stepcounter{counter}
%
%  \begin{center}\textit{Q\arabic{counter}: how to make the above rate negligibly small?}
%  \end{center}
%
%
%
%There exists  a comprehensive research line in determining the effectiveness of warnings, e.g., in \cite{laughery2006designing,brinton2016users,felt2014experimenting}. These traditional research line  studies which factors make warnings effective and how a warning recipient is attracted to and follows the warning message.  However, in the context of APP scams, there is a vital  unique factor  that can directly influence a warning effectiveness; the factor is    \emph{the ability of the scammer to interact directly with the victim} (or warning recipient). This lets a scammer to actively try to negate  the effectiveness of banks' warnings and persuade the warning recipient to ignore the warning (and make  payment). Such a factor was not (needed to be) taken into account in the traditional study of warnings. Therefore, one may ask: 
%
%\stepcounter{counter}
%  \begin{center}\textit{Q\arabic{counter}: to what extent can a scammer  negate a warning effectiveness in the onctext of APP scams?}
%  \end{center}
%
%
%One way to answer the above question is to study each individual bank's statistics and find out how successful they have been in combatting the APP scams, as each bank designs its payment system and warnings independent of other banks. Thus, it would be interesting to find out:
%\stepcounter{counter}
%  \begin{center}\textit{Q\arabic{counter}: which bank  does have  the  lowest rate of APP scams and how did its warnings contribute to the low rate?}  
%  \end{center}
%
%
%Furthermore, in step \ref{arbiters-verdict}, it is implicitly assumed that in order for each arbiter, $\mathcal{D}_{\st i}$, to judge  the effectiveness of the warning and reach a verdict, it has access to the payment system and it can interact  with  $\mathcal{C}$ offline, e.g., to obtain further evidence from it.  Nevertheless, this process can be time consuming and a verdict may not be released in the real time once $\mathcal{C}$ sends its complaint to $\mathcal{S}$. Thus, it is natural to ask: 
%
%\stepcounter{counter}
%\begin{center}\textit{Q\arabic{counter}: to what extent can the role of the arbiters  be automated and accurately played by a computer program?}
%\end{center}
%
%%Recall, the  above protocol assumes that the customer does not collude with the APP scammer. However, this assumption may not always hold in the real world. The two parties may collude to exploit  the payment system's weaknesses, e.g., ineffective warning.  In this case,  the malicious customer honestly participates in the protocol but   ignores the warning and makes a payment. Later, it raises a dispute and challenges the warning's effectiveness. It would succeed and be identified as a party who should be reimbursed, if the committee approves that the warning is indeed ineffective. The main difference between this case and the one  where the customer falls victim to an APP scam  is that in the former  the  customer makes extra money while in the latter  it does not. Hence, it is reasonable to ask:
%%
%%\stepcounter{counter}
%%\begin{center}\textit{Q\arabic{counter}: how to relax the above non-colluding assumption while being able to distinguish an honest customer who has fallen victim to  an APP scam from a malicious customer who colludes with the APP scammer?}
%%\end{center}
%
% \subsection{Ensuring the Payment is for Genuine Goods and Services}\label{sec:genuine-goods}
% 
% 
% 
%There are a set of terms in the CRM code  that states: 
%
%\noindent\textit{``In all the circumstances at the time of the payment, in particular the characteristics of the Customer and the complexity and sophistication of the APP scam, the Customer made the payment without a reasonable basis for believing that:}
%\begin{itemize}
%\item[(i)] \textit{the payee was the person the Customer was expecting to pay;}
%\item[(ii)] \textit{the payment was for genuine goods or services; and/or}
%\item[(iii)] \textit{the person or business with whom they transacted was legitimate".}
%\end{itemize}
%
%
%We argue that    clause (ii) plays a minor role in  preventing a APP scam, as it is effective only when the seller wrongly claims it is in possession of a certain goods or can deliver certain services. It is ineffective when   a customer  ensures goods or services it wants to receive are indeed genuine but the seller avoids delivering the goods/services.  In this case, a seller (regardless of whether it is legitimate or not) may prove to the customer that the goods and services are genuine and belong to it (e.g., by sending a copy of related genuine  document), but it   still avoids delivering them once it receives the money. To capture the above issue as well, the above clause should be modified as follows: 
%
%%\begin{center}\textit{``... the payment was made (if and) only if the delivery of genuine good or services are guaranteed''.}
%% \end{center}
% 
%\begin{center}\textit{``... the delivery of genuine goods or services are guaranteed...''.}
% \end{center}
% 
%There are at least two ways to have the above guarantee: (a) involving a reputable trusted third-party intermediary which can compensate the customer if the seller misbehaves, e.g., eBay, amazon, or (b)  using a secure ``contingent service payment" scheme (e.g., in  \cite{CampanelliGGN17}) that supports the  fair exchange of digital goods or services and money without the involvement of the above trusted third-party intermediary. In this case, there would be no need for the customer to ensure if the seller is legitimate, because it pays only if  genuine goods or services are delivered. The existing fair exchange schemes  allow a seller and buyer to trade with each other \emph{outside of the bank payment system} by using a blockchain. However, these schemes can be embedded into the bank payment system such that the bank (or a group of banks) maintains the blockchain and converts internally  a customer's  fiat currency  to a digital one when the customer wants to trade in a fair manner with a party whose authenticity cannot be verified. 
%
%
%\subsection{Ensuring the Legitimacy and Authenticity of Payee}
%
%We highlight that even though clauses (i) and (iii), presented in  Section \ref{sec:genuine-goods}, can prevent a customer from falling to an APP scam, only in certain cases they would   benefit a victim of an APP fraud during the process of allocating liability or dispute resolution.  In particular, if the victim declares that (a)   it has used a   secure authentication mechanism (e.g., digital signature) to ensure  the legitimacy and authenticity of the payee or (b)  it has not performed any authentication, then it would not receive the reimbursement. In the former case, it has transferred the  money to the party it knows. However,   this  is not an APP scam,  according to the scam's general definition.  In the latter case, the firm can avoid reimbursing it, according to the CRM code (as the customer has not performed its part). The only case in which the customer might be reimbursed is when it (a) uses an insecure means for authentication (e.g., phone call) and (b) can prove it has done such a check. For instance, in the case where the victim has been asked by a scammer to make a phone call to its bank while the scammer  answers the phone call that the victim makes later. In this case, the victim needs to  prove that it has made a phone call to the bank, which may not be always possible (e.g., if the scammer uses a method to reply to the call before the real connection between the customer and bank is made).  In this case, in order for the customer to be reimbursed it needs to provide an evidence while there is no evidence left behind by the scammer. Thus, it is natural to ask:
%
%\stepcounter{counter}
%\begin{center}\textit{Q\arabic{counter}: how can the victim prove it has been a victim of an APP scam, in the above case?}
%\end{center}
%
%\subsection{Lack of Gross Negligence Definition}
%
%One of the conditions in the CRM code that allows a bank to avoid reimbursing the customer is clause R2(1)(e) which states: 
%
%
%\begin{center}\textit{``The Customer has been grossly negligent. For the avoidance of doubt the provisions of R2(1)(a)-(d) should not be taken to define gross negligence in this context.''}
% \end{center}
% 
% Nevertheless, neither the CRM code  nor the Payment Services Regulations   explicitly define under which circumstances the customer is considered ``grossly negligent'' in the context of the APP scam. In particular, in the CRM code, the only terms that discuss customer's misbehaviour are  the provisions of R2(1)(a)-(d); however, as stated above, they should be excluded from the definition of the term gross negligence. On the  other hand,  in the Payment Services Regulations, this term is used three times, i.e.,  twice in regulation 75 and once in regulation 77. But in all  three cases it is used for frauds related to \emph{unauthorised payments} which are  different types of frauds from the APP scams. Therefore, even the Payment Services Regulations does not define the term in the context of the APP scam. 
% 
% When an  accurate definition of the term is in place,  its conditions can be encoded into the smart contract of the PwDR protocol. This allows the PwDR protocol to transparently resolve  disputes  between the bank and customer, if the bank claims that the customer has been  grossly negligent. 



