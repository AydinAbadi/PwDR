% !TEX root =main.tex

\section{Evaluation}
In this section, we provide the PwDR protocolâ€™s asymptotic computation and communication cost analysis. Table \ref{} summarises the result. 


\subsection{Computation Cost} In this section, we analyse the computation cost of the protocol. We first analyse $\mathcal{C}$'s cost. In Phase \ref{customer-side-Initiation}, $\mathcal{C}$ invokes a hash function twice to check the private statements' parameters. In Phase \ref{genUpdateRequest}, it invokes the symmetric encryption once to encrypt its update request. In Phase \ref{clinet-at-T2}, it invokes  the symmetric encryption twice to decrypt $\mathcal{B}$'s warning message and to encrypt its payment request. In Phase \ref{Generating-Complaint}, it runs  the symmetric encryption twice to decrypt $\mathcal{B}$'s warning and payment messages and to encrypt its complaint. In the same phase, it invokes the asymmetric encryption to encrypt the private statements' opening. Therefore, $\mathcal{C}$'s complexity   is  $O(1)$. Next, we analyse $\mathcal{B}$'s cost. In Phase \ref{RCPoRP::Bank-side-Initiation}, it invokes the hash function twice to commit  to  two statements. In Phase \ref{Generating-Warning}, it calls the symmetric key encryption once to encrypt the outgoing warning message. In Phase \ref{Making-Payment}, it also invokes  the symmetric key encryption once to encrypt the outgoing payment message. Thus, $\mathcal{B}$'s complexity   is  $O(1)$ too. Next, we analyse each arbiter's cost. In Phase \ref{VerifyingComplaint}, each $\mathcal{D}_{\st j}$ invokes the asymmetric key encryption once to decrypt the private statements' openings. It also invokes the hash function twice to verify the openings. It invokes the symmetric key encryption six times to decrypt $\mathcal{C}$'s and $\mathcal{B}$'s messages posted on $\mathcal{S}$ (this includes $\mathcal{C}$'s complaint). Recall, in the same phase, each arbiter encodes its verdict using a verdict encoding protocol. Now, we evaluate the verdict encoding complexity of each arbiter in two cases: (a)   $e=1$ and (b) $e\in(1, n]$. Note, in the former case the PVE is invoked while in the latter GPVE is called. In case (a), every arbiter $\mathcal{D}_{\st j}$ except $\mathcal{D}_{\st n}$ invokes the pseudorandom function once to encode its verdict. However,  arbiter $\mathcal{D}_{\st n}$ invokes the pseudorandom function $n-1$ times and XORs the function's outputs with each other. Thus, in  case (a), arbiter $\mathcal{D}_{\st n}$'s complexity is $O(n)$ while the ret of arbiters' complexity is $O(1)$.  In case (b), every arbiter $\mathcal{D}_{\st j}$ except $\mathcal{D}_{\st n}$ invokes the pseudorandom function twice to encode its verdict.  But,  arbiter $\mathcal{D}_{\st n}$ invokes the pseudorandom function $n-1$ times and XORs the function's outputs with each other. It also invokes  the pseudorandom function $n$ times to generate all arbiters' representations of verdict $1$. It computes all $y=\sum\limits_{\st i=e}^{\st n}\frac{n!}{i!(n- i)!}$ combinations of the representations that meet the threshold which involves $O(y)$ XORs. It also encodes $y$ elements into a Bloom filter that requires  $O(y)$ hash function evaluations. So, in case (b), arbiter $\mathcal{D}_{\st n}$'s complexity is $O(y)$ while the ret of arbiters' complexity is $O(1)$. To conclude, in Phase \ref{VerifyingComplaint},  arbiter $\mathcal{D}_{\st n}$'s complexity is either $O(n)$ or $O(y)$, while the rest of arbiters' complexity is $O(1)$. 







\subsection{Communication Cost}






